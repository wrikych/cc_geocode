<script>
  async function optimize(orsKey, startAddr, endAddr, stopAddrs, withService){
    setStatus("Geocoding addresses…");
    const allAddrs = [startAddr, ...stopAddrs, endAddr];

    // Geocode sequentially for clear error messages
    const geocoded = [];
    for(let i=0;i<allAddrs.length;i++){
      setStatus(`Geocoding (${i+1}/${allAddrs.length}): ${allAddrs[i]}`);
      geocoded.push(await geocode(orsKey, allAddrs[i]));
    }
    const start = geocoded[0], end = geocoded[geocoded.length-1];
    const stops = geocoded.slice(1, -1);

    // Build Optimization payload (VROOM via ORS)
    const jobs = stops.map((c, idx)=>({
      id: idx+1,
      location: [c.lon, c.lat],
      service: withService ? 3600 : 0 // 1h dwell per stop if requested
    }));
    const body = {
      jobs,
      vehicles: [{
        id: 1,
        profile: "driving-car",
        start: [start.lon, start.lat],
        end:   [end.lon,   end.lat]
      }],
      // Ask for geometry if available
      options: { g: true }
    };

    setStatus("Calling ORS Optimization…");
    const r = await fetch("https://api.openrouteservice.org/optimization", {
      method: "POST",
      headers: {
        "Authorization": orsKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if(!r.ok){
      const txt = await r.text();
      throw new Error("Optimization error: " + r.status + " " + txt);
    }
    const plan = await r.json();
    const route = (plan.routes||[])[0];
    if(!route) throw new Error("No route found.");

    // Build ordered address list from steps
    const stepSeq = route.steps; // sequence of {type: 'start'|'job'|'end', id?}
    const ordered = [];
    ordered.push(startAddr);
    for(const s of stepSeq){
      if(s.type === "job"){
        // id is 1-based index matching our jobs array
        const originalIndex = s.id - 1;
        ordered.push(stopAddrs[originalIndex]);
      }
    }
    ordered.push(endAddr);

    // Try to get geometry from optimization; if invalid or missing, fallback to Directions
    let geojsonRoute = null;
    if (route.geometry && typeof route.geometry === "object" && route.geometry.type === "LineString") {
      // Optimization already returned a LineString GeoJSON
      geojsonRoute = { type: "Feature", geometry: route.geometry, properties: {} };
    } else {
      // Fallback: call Directions with the optimized order to get a GeoJSON linestring
      setStatus("Fetching route geometry (Directions)…");
      const coordsOrdered = [];
      // start
      coordsOrdered.push([start.lon, start.lat]);
      // jobs in optimized order
      for(const s of stepSeq){
        if(s.type === "job"){
          const c = stops[s.id - 1];
          coordsOrdered.push([c.lon, c.lat]);
        }
      }
      // end
      coordsOrdered.push([end.lon, end.lat]);

      const dr = await fetch("https://api.openrouteservice.org/v2/directions/driving-car/geojson", {
        method: "POST",
        headers: {
          "Authorization": orsKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ coordinates: coordsOrdered })
      });
      if(!dr.ok){
        const txt = await dr.text();
        throw new Error("Directions error: " + dr.status + " " + txt);
      }
      const dj = await dr.json();
      // ORS Directions GeoJSON returns a FeatureCollection
      // Use the first feature (LineString)
      if(dj && dj.type === "FeatureCollection" && dj.features && dj.features.length){
        geojsonRoute = dj.features[0];
      } else {
        throw new Error("Invalid Directions GeoJSON.");
      }
    }

    // Draw on Leaflet
    clearMap();
    if(!map){
      map = L.map("map");
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);
    }
    lineLayer = L.geoJSON(geojsonRoute).addTo(map);

    // Markers (ordered)
    let idx = 1;
    markers.push(L.marker([start.lat,start.lon]).addTo(map).bindPopup(`${idx++}. ${startAddr}`));
    for(const s of stepSeq){
      if(s.type === "job"){
        const c = stops[s.id - 1];
        const addr = stopAddrs[s.id - 1];
        markers.push(L.marker([c.lat,c.lon]).addTo(map).bindPopup(`${idx++}. ${addr}`));
      }
    }
    markers.push(L.marker([end.lat,end.lon]).addTo(map).bindPopup(`${idx++}. ${endAddr}`));

    map.fitBounds(lineLayer.getBounds(), {padding:[30,30]});

    // Show list & Google Maps link
    orderList.innerHTML = "";
    ordered.forEach(a=>{
      const li = document.createElement("li");
      li.textContent = a;
      orderList.appendChild(li);
    });
    gmapLink.href = googleMapsLink(ordered);
    gmapLink.style.display = "inline-block";
    setStatus("Done.");
  }
</script>
