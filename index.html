<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Route Optimizer (Static)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:1000px;margin:2rem auto;padding:0 1rem}
    .card{border:1px solid #e5e7eb;border-radius:12px;padding:1rem;box-shadow:0 1px 2px rgba(0,0,0,.05)}
    #map{height:70vh;border-radius:12px;border:1px solid #e5e7eb;margin-top:1rem}
    button{padding:.6rem 1rem;border-radius:10px;border:0;background:#111827;color:#fff;font-weight:600;cursor:pointer}
    input[type="file"]{margin:.5rem 0}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .muted{color:#6b7280}
    ol{padding-left:1.25rem}
    a.button{display:inline-block;padding:.6rem 1rem;border-radius:10px;background:#111827;color:#fff;text-decoration:none;font-weight:600}
  </style>
</head>
<body>
  <h1>Route Optimizer (Static)</h1>
  <div class="card">
    <div class="row">
      <label>OpenRouteService API key:
        <input id="apiKey" type="password" placeholder="eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6IjczNjJkNmI1ZWVkODQ5NmE4ZDNlYmQ3ODU0MzhhZWVlIiwiaCI6Im11cm11cjY0In0=" style="width:320px"/>
      </label>
      <label><input id="withService" type="checkbox"> 1 hour at each stop</label>
    </div>
    <label>Upload 1-column CSV (Row1=start, Row2=end, Rows3..N=stops). Header optional.</label>
    <input id="csvFile" type="file" accept=".csv"/>
    <div class="row">
      <button id="runBtn">Optimize</button>
      <button id="sampleBtn" type="button">Load sample</button>
    </div>
    <p class="muted" id="status"></p>
  </div>

  <div class="card" style="margin-top:1rem">
    <h3>Visit order</h3>
    <ol id="orderList"></ol>
    <p><a id="gmapLink" class="button" href="#" target="_blank" rel="noopener" style="display:none">Open in Google Maps</a></p>
    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  async function optimize(orsKey, startAddr, endAddr, stopAddrs, withService){
    setStatus("Geocoding addresses…");
    const allAddrs = [startAddr, ...stopAddrs, endAddr];

    // Geocode sequentially for clear error messages
    const geocoded = [];
    for(let i=0;i<allAddrs.length;i++){
      setStatus(`Geocoding (${i+1}/${allAddrs.length}): ${allAddrs[i]}`);
      geocoded.push(await geocode(orsKey, allAddrs[i]));
    }
    const start = geocoded[0], end = geocoded[geocoded.length-1];
    const stops = geocoded.slice(1, -1);

    // Build Optimization payload (VROOM via ORS)
    const jobs = stops.map((c, idx)=>({
      id: idx+1,
      location: [c.lon, c.lat],
      service: withService ? 3600 : 0 // 1h dwell per stop if requested
    }));
    const body = {
      jobs,
      vehicles: [{
        id: 1,
        profile: "driving-car",
        start: [start.lon, start.lat],
        end:   [end.lon,   end.lat]
      }],
      // Ask for geometry if available
      options: { g: true }
    };

    setStatus("Calling ORS Optimization…");
    const r = await fetch("https://api.openrouteservice.org/optimization", {
      method: "POST",
      headers: {
        "Authorization": orsKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    if(!r.ok){
      const txt = await r.text();
      throw new Error("Optimization error: " + r.status + " " + txt);
    }
    const plan = await r.json();
    const route = (plan.routes||[])[0];
    if(!route) throw new Error("No route found.");

    // Build ordered address list from steps
    const stepSeq = route.steps; // sequence of {type: 'start'|'job'|'end', id?}
    const ordered = [];
    ordered.push(startAddr);
    for(const s of stepSeq){
      if(s.type === "job"){
        // id is 1-based index matching our jobs array
        const originalIndex = s.id - 1;
        ordered.push(stopAddrs[originalIndex]);
      }
    }
    ordered.push(endAddr);

    // Try to get geometry from optimization; if invalid or missing, fallback to Directions
    let geojsonRoute = null;
    if (route.geometry && typeof route.geometry === "object" && route.geometry.type === "LineString") {
      // Optimization already returned a LineString GeoJSON
      geojsonRoute = { type: "Feature", geometry: route.geometry, properties: {} };
    } else {
      // Fallback: call Directions with the optimized order to get a GeoJSON linestring
      setStatus("Fetching route geometry (Directions)…");
      const coordsOrdered = [];
      // start
      coordsOrdered.push([start.lon, start.lat]);
      // jobs in optimized order
      for(const s of stepSeq){
        if(s.type === "job"){
          const c = stops[s.id - 1];
          coordsOrdered.push([c.lon, c.lat]);
        }
      }
      // end
      coordsOrdered.push([end.lon, end.lat]);

      const dr = await fetch("https://api.openrouteservice.org/v2/directions/driving-car/geojson", {
        method: "POST",
        headers: {
          "Authorization": orsKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ coordinates: coordsOrdered })
      });
      if(!dr.ok){
        const txt = await dr.text();
        throw new Error("Directions error: " + dr.status + " " + txt);
      }
      const dj = await dr.json();
      // ORS Directions GeoJSON returns a FeatureCollection
      // Use the first feature (LineString)
      if(dj && dj.type === "FeatureCollection" && dj.features && dj.features.length){
        geojsonRoute = dj.features[0];
      } else {
        throw new Error("Invalid Directions GeoJSON.");
      }
    }

    // Draw on Leaflet
    clearMap();
    if(!map){
      map = L.map("map");
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);
    }
    lineLayer = L.geoJSON(geojsonRoute).addTo(map);

    // Markers (ordered)
    let idx = 1;
    markers.push(L.marker([start.lat,start.lon]).addTo(map).bindPopup(`${idx++}. ${startAddr}`));
    for(const s of stepSeq){
      if(s.type === "job"){
        const c = stops[s.id - 1];
        const addr = stopAddrs[s.id - 1];
        markers.push(L.marker([c.lat,c.lon]).addTo(map).bindPopup(`${idx++}. ${addr}`));
      }
    }
    markers.push(L.marker([end.lat,end.lon]).addTo(map).bindPopup(`${idx++}. ${endAddr}`));

    map.fitBounds(lineLayer.getBounds(), {padding:[30,30]});

    // Show list & Google Maps link
    orderList.innerHTML = "";
    ordered.forEach(a=>{
      const li = document.createElement("li");
      li.textContent = a;
      orderList.appendChild(li);
    });
    gmapLink.href = googleMapsLink(ordered);
    gmapLink.style.display = "inline-block";
    setStatus("Done.");
  }
</script>

</body>
</html>
